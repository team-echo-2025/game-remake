import { Framebuffer, XML } from "p5";
import GameObject from "../GameObject";
import Scene from "../Scene";
import Tileset from "./Tileset";
import TLayer from "./TLayer";
import TLayerChunk from "./TLayerChunk";
import { Vector2D } from "../types/Physics";

export type TilemapProps = Readonly<{
    tilemap_key: string;
    x?: number;
    y?: number;
    chunk_size?: number;
    loaded_chunks?: number;
}>

class TilemapBuffer implements GameObject {
    zIndex?: number = -100;
    x: number;
    y: number;
    width: number;
    height: number;
    buffer: Framebuffer;
    scene: Scene;
    constructor(x: number, y: number, width: number, height: number, buffer: Framebuffer, scene: Scene) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.buffer = buffer;
        this.scene = scene;
    }
    draw(): void {
        this.scene.p5.push();
        this.scene.p5.translate(-this.width / 2, - this.height / 2);
        this.scene.p5.image(this.buffer, this.x, this.y);
        this.scene.p5.pop();
    }
}

export default class Tilemap implements GameObject {
    private _scene!: Scene;
    private tilemap_key: string;
    private tilemap!: XML;
    private _tilesets!: Tileset[];
    private layers!: TLayer[];
    private _width!: number;
    private _height!: number;
    private _tilewidth!: number;
    private _tileheight!: number;
    private _x: number;
    private _y: number;
    private _current_chunk_index: Vector2D = { x: 0, y: 0 };
    private _loaded_chunks: TLayerChunk[] = [];
    buffer!: Framebuffer;
    player_buffer!: Framebuffer;
    minx: number = 0;
    maxx: number = 0;
    miny: number = 0;
    maxy: number = 0;
    chunks: Map<string, TLayerChunk> = new Map();

    get x() {
        return this._x;
    }

    get y() {
        return this._y;
    }

    get width() {
        return this._width;
    }

    set width(width: number) {
        this._width = width;
    }

    get height() {
        return this._height;
    }

    set height(height: number) {
        this._height = height;
    }

    get tilewidth() {
        return this._tilewidth;
    }

    get tileheight() {
        return this._tileheight;
    }

    get tilesets() {
        return this._tilesets;
    }

    set scene(scene: Scene) {
        this._scene = scene;
    }

    constructor(props: TilemapProps) {
        this.tilemap_key = props.tilemap_key;
        this._x = props.x ?? 0;
        this._y = props.y ?? 0;
        this._tilesets = [];
        this.layers = [];
    }

    async preload(): Promise<any> { }

    key_for = (vec: Vector2D) => {
        return `${vec.x}:${vec.y}`;
    }

    setup(): void {
        this.tilemap = this._scene.get_asset(this.tilemap_key);
        this._tilewidth = this.tilemap.getNum('tilewidth')
        this._tileheight = this.tilemap.getNum('tileheight')
        this._width = this.tilemap.getNum('width')
        this._height = this.tilemap.getNum('height')
        for (let item of this.tilemap!.getChildren()) {
            const name = item.getName();
            if (name == "tileset") {
                const source = item.getString('source');
                const tileset = new Tileset({ tileset_ref: item, tileset_key: `${this.tilemap_key}/${source}`, scene: this._scene })
                tileset.setup();
                this._tilesets.push(tileset)
            }
        }
        for (let item of this.tilemap!.getChildren()) {
            const name = item.getName();
            if (name == "layer") {
                const layer = new TLayer({ layer: item, scene: this._scene, tilemap: this });
                layer.x = this._x;
                layer.y = this._y;
                this.layers.push(layer);
                layer.setup_layer();
            }
        }
        this._tilesets.sort((item1, item2) => item1.firstgid > item2.firstgid ? 1 : item1.firstgid == item2.firstgid ? 0 : -1)

        for (const layer of this.layers) {
            if (layer.minx < this.minx) {
                this.minx = layer.minx;
            }
            if (layer.maxx > this.maxx) {
                this.maxx = layer.maxx;
            }
            if (layer.miny < this.miny) {
                this.miny = layer.miny;
            }
            if (layer.maxy > this.maxy) {
                this.maxy = layer.maxy;
            }
        }

        this._width = this.maxx - this.minx;
        this._height = this.maxy - this.miny;
        console.log(this.minx, this.maxx)
        console.log("SETUP")

        this.buffer = this._scene.p5.createFramebuffer({
            width: this._width,
            height: this._height,
        })!;
        this.player_buffer = this._scene.p5.createFramebuffer({
            width: this._width,
            height: this._height,
        })!;

        const tilemap_buffer = new TilemapBuffer(this.x, this.y, this._scene.p5.width, this._scene.p5.height, this.buffer, this._scene);
        this._scene.add(tilemap_buffer);
        const player_buffer = new TilemapBuffer(this.x, this.y, this.width, this.height, this.player_buffer, this._scene);
        this.player_buffer.begin();
        player_buffer.zIndex = 100;
        this._scene.add(player_buffer);
        this._scene.p5.push();
        this._scene.p5.rectMode("corner");
        this._scene.p5.noFill();
        this._scene.p5.stroke(255, 0, 0);
        this._scene.p5.rect(this.x - this._width / 2, this.y - this._height / 2, this._width, this._height);
        this._scene.p5.pop();
        this.player_buffer.end();

        for (const [_, chunk] of this.chunks) {
            chunk.preload();
        }

        console.log(this.chunks);
        this.load_chunks();
        //for (const [_, chunk] of this.chunks) {
        //    chunk.load(this.buffer);
        //}
    }

    draw(): void {
        const { x, y } = this.get_camera_index();
        if (x != this._current_chunk_index.x || y != this._current_chunk_index.y) {
            this.load_chunks();
        }
    }

    get_camera_index = (): Vector2D => {
        const CHUNK_PIXEL_WIDTH = 16 * this.tilewidth;  // 16×32
        const CHUNK_PIXEL_HEIGHT = 16 * this.tileheight; // 16×32
        const cam_chunkx = Math.floor((this._scene.camera.x) / CHUNK_PIXEL_WIDTH);
        const cam_chunky = Math.floor((this._scene.camera.y) / CHUNK_PIXEL_HEIGHT);
        return { x: cam_chunkx, y: cam_chunky };
    }

    load_chunks = () => {
        for (const loaded_chunk of this._loaded_chunks) {
            loaded_chunk.unload();
        }
        this._loaded_chunks = [];
        const cam_chunksx = Math.ceil(this._scene.camera.bounds.halfWidth * 2 / (16 * this.tilewidth));
        const cam_chunksy = Math.ceil(this._scene.camera.bounds.halfHeight * 2 / (16 * this.tilewidth));
        console.log(cam_chunksx, cam_chunksy);
        const { x: cam_chunkx, y: cam_chunky } = this.get_camera_index();
        this._current_chunk_index = { x: cam_chunkx, y: cam_chunky };
        for (let row = Math.floor(cam_chunky - cam_chunksy / 2); row <= Math.floor(cam_chunky + cam_chunksy / 2); row++) {
            for (let col = Math.floor(cam_chunkx - cam_chunksx / 2); col <= Math.floor(cam_chunkx + cam_chunksx / 2); col++) {
                console.log(this.key_for({ x: col * 16, y: row * 16 }));
                const chunk = this.chunks.get(this.key_for({ x: col * 16, y: row * 16 }));
                if (chunk && !chunk.loaded) {
                    chunk.load(this.buffer);
                    this._loaded_chunks.push(chunk);
                }
            }
        }
        console.log(this._loaded_chunks.length, " LOADED CHUNKS")
        console.log(cam_chunkx, cam_chunky)
    }
}
